require('dotenv').config();
const { Client, GatewayIntentBits, Partials, Events, EmbedBuilder } = require('discord.js');
const connectDB = require('./config/database');
const { handleMessageCreate } = require('./events/messageCreate');
const SpiritRingController = require('./controllers/DauLaDaiLuc/spiritRingController');
const Notification = require('./models/Notification');
const SettingController = require('./controllers/settingController');
const { cleanupTempImages } = require('./utils/drawImage');
try {
    const client = new Client({
        intents: [
            GatewayIntentBits.Guilds,
            GatewayIntentBits.GuildMessages,
            GatewayIntentBits.GuildMembers,
            GatewayIntentBits.MessageContent,
            GatewayIntentBits.DirectMessages,
            GatewayIntentBits.DirectMessageReactions,
            GatewayIntentBits.GuildMessageReactions
        ],
        partials: [Partials.Channel, Partials.Message, Partials.Reaction, Partials.User]
    });

    // K·∫øt n·ªëi database
    connectDB();
    cleanupTempImages()
    // S·ª± ki·ªán
    client.once('ready', () => {
        console.log(`‚úÖ Bot ƒë√£ ƒëƒÉng nh·∫≠p v·ªõi t√™n: ${client.user.tag}`);
        const developerUser = client.users.cache.get(process.env.DEVELOPER_ID);

        if (developerUser) {
            let guildList = "";
            client.guilds.cache.forEach(guild => {
                guildList += `üìå ${guild.name} (ID: ${guild.id}) | üë• ${guild.memberCount} th√†nh vi√™n\n`;
            });

            const embed = new EmbedBuilder()
                .setTitle("üìä Danh s√°ch server bot ƒë√£ join")
                .setDescription(guildList || "Bot ch∆∞a tham gia server n√†o.")
                .setColor("Blue");

            developerUser.send({ embeds: [embed] }).catch(err => {
                console.error("Kh√¥ng th·ªÉ g·ª≠i DM t·ªõi developer:", err);
            });
        }
    });
    // S·ª± ki·ªán th√†nh vi√™n tham gia
    client.on('guildMemberAdd', async (member) => {
        console.log("add");
        
        await SettingController.sendNotification(member.guild.id, 'welcome', member,client);
    });

    // S·ª± ki·ªán th√†nh vi√™n r·ªùi ƒëi
    client.on('guildMemberRemove', async (member) => {
        console.log("remove");
        await SettingController.sendNotification(member.guild.id, 'goodbye', member,client);
    });

    // S·ª± ki·ªán boost server
    client.on('guildMemberUpdate', async (oldMember, newMember) => {
        if (!oldMember.premiumSince && newMember.premiumSince) {
            await SettingController.sendNotification(newMember.guild.id, 'booster', newMember,client, true);
        }
    });
    client.on('messageCreate', async (message) => {
        try {
            await handleMessageCreate(client, message);
        } catch (error) {
            console.error("‚ö†Ô∏è L·ªói interactionCreate:", error);

            // G·ª≠i b√°o c√°o bug t·ªõi dev
            const devUser = await client.users.fetch(process.env.DEVELOPER_ID);
            if (devUser) {
                await devUser.send({
                    content: `üêû **B√°o c√°o l·ªói messageCreate**\n` +
                        `**User:** ${message.author.username} (${message.author.id})\n` +
                        `**Interaction Type:** ${message.type}\n` +
                        `**Error:**\n\`\`\`${error.stack}\`\`\``
                });
            }
        }
    });
    client.on('messageReactionAdd', async (reaction, user) => {
        if (user.bot) return;
        // N·∫øu message ch∆∞a cache th√¨ fetch
        if (reaction.partial) {
            try {
                await reaction.fetch();
            } catch (err) {
                console.error("Can't fetch reaction:", err);
                return;
            }
        }
    })
    client.on('interactionCreate', async (interaction) => {
        try {
            if (interaction.isCommand() || interaction.isChatInputCommand()) {
                await require('./events/handleInteractionCreate')(interaction, client);
            } else if (interaction.isStringSelectMenu() || interaction.isSelectMenu()) {
                await require('./events/handleInteractionSelectCreate')(interaction);
            } else if (interaction.isButton()) {
                await require('./events/handleButtonInteraction')(interaction);
            }
        } catch (error) {
            console.error("‚ö†Ô∏è L·ªói interactionCreate:", error);

            // G·ª≠i b√°o c√°o bug t·ªõi dev
            const devUser = await client.users.fetch(process.env.DEVELOPER_ID);
            if (devUser) {
                await devUser.send({
                    content: `üêû **B√°o c√°o l·ªói interaction**\n` +
                        `**User:** ${interaction.user.tag} (${interaction.user.id})\n` +
                        `**Interaction Type:** ${interaction.type}\n` +
                        `**Error:**\n\`\`\`${error.stack}\`\`\``
                });
            }
        }
    });
    // X·ª≠ l√Ω interactions
    client.on('interactionCreate', async (interaction) => {
        if (interaction.isModalSubmit()) {
            const [cusId, selectedType, channelId] = interaction.customId.split('|')
            if (cusId === 'setupModal') {
                await interaction.deferReply({ ephemeral: true });

                // L·∫•y gi√° tr·ªã t·ª´ modal
                const type = selectedType;
                // const channelId = channelId;
                const title = interaction.fields.getTextInputValue('titleInput') || '';
                const description = interaction.fields.getTextInputValue('descriptionInput') || '';
                const imageUrl = interaction.fields.getTextInputValue('imageInput') || '';

                // Ki·ªÉm tra lo·∫°i th√¥ng b√°o h·ª£p l·ªá
                if (!['welcome', 'goodbye', 'booster'].includes(type.toLowerCase())) {
                    return interaction.editReply({
                        content: 'Lo·∫°i th√¥ng b√°o kh√¥ng h·ª£p l·ªá. Vui l√≤ng s·ª≠ d·ª•ng welcome, goodbye ho·∫∑c booster.'
                    });
                }

                try {
                    let notificationConfig = await Notification.findOne({ guildId: interaction.guildId });

                    if (!notificationConfig) {
                        notificationConfig = new Notification({
                            guildId: interaction.guildId,
                            channels: []
                        });
                    }

                    // X√≥a c·∫•u h√¨nh c≈© n·∫øu c√≥
                    notificationConfig.channels = notificationConfig.channels.filter(c => c.channelType !== type);

                    // Thi·∫øt l·∫≠p gi√° tr·ªã m·∫∑c ƒë·ªãnh n·∫øu kh√¥ng c√≥
                    const finalTitle = title || (type === 'welcome' ? 'Ch√†o m·ª´ng {user} ƒë·∫øn v·ªõi {guild}!' :
                        type === 'goodbye' ? 'T·∫°m bi·ªát {user}!' : 'C·∫£m ∆°n {user} ƒë√£ boost server!');

                    const finalDescription = description || (type === 'welcome' ? 'Xin ch√†o {user.mention}! Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi {guild}. Hi·ªán t·∫°i ch√∫ng t√¥i c√≥ {memberCount} th√†nh vi√™n.' :
                        type === 'goodbye' ? '{user} ƒë√£ r·ªùi kh·ªèi {guild}. Hi·ªán t·∫°i ch√∫ng t√¥i c√≤n {memberCount} th√†nh vi√™n.' :
                            'C·∫£m ∆°n {user.mention} ƒë√£ boost server {guild}!');

                    // Th√™m c·∫•u h√¨nh m·ªõi
                    notificationConfig.channels.push({
                        channelId: channelId,
                        channelType: type,
                        title: finalTitle,
                        description: finalDescription,
                        imageUrl: imageUrl
                    });

                    await notificationConfig.save();

                    const embed = new EmbedBuilder()
                        .setTitle('Thi·∫øt l·∫≠p th√¥ng b√°o th√†nh c√¥ng!')
                        .setDescription(`ƒê√£ thi·∫øt l·∫≠p k√™nh th√¥ng b√°o ${type} cho k√™nh <#${channelId}>`)
                        .addFields(
                            { name: 'Ti√™u ƒë·ªÅ', value: finalTitle },
                            { name: 'M√¥ t·∫£', value: finalDescription }
                        )
                        .setColor(0x00FF00)
                        .setTimestamp();

                    if (imageUrl) {
                        embed.setImage(imageUrl);
                    }

                    await interaction.editReply({ embeds: [embed] });
                } catch (error) {
                    console.error('L·ªói khi thi·∫øt l·∫≠p th√¥ng b√°o:', error);
                    await interaction.editReply({
                        content: 'ƒê√£ x·∫£y ra l·ªói khi thi·∫øt l·∫≠p th√¥ng b√°o. Vui l√≤ng th·ª≠ l·∫°i sau.'
                    });
                }
            }
        }
        if (!interaction.isButton() && !interaction.isStringSelectMenu()) return;

        // Ki·ªÉm tra xem interaction ƒë√£ ƒë∆∞·ª£c tr·∫£ l·ªùi ch∆∞a
        if (interaction.replied || interaction.deferred) {
            return;
        }

        try {
            // X·ª≠ l√Ω select menu sort
            if (interaction.customId.startsWith('spirit_rings_sort_')) {
                const userId = interaction.customId.split('_')[3];
                const sortBy = interaction.values[0];

                // Defer update ƒë·ªÉ tr√°nh l·ªói timeout
                await interaction.deferUpdate();

                const { embeds, components } = await SpiritRingController.getSpiritRingsEmbed(userId, 1, sortBy);
                await interaction.editReply({ embeds, components });
            }

            // X·ª≠ l√Ω select menu range filter
            else if (interaction.customId.startsWith('spirit_rings_range_')) {
                const userId = interaction.customId.split('_')[3];
                const rangeFilter = interaction.values[0];

                await interaction.deferUpdate();

                const { embeds, components } = await SpiritRingController.getSpiritRingsEmbed(userId, 1, 'years', rangeFilter);
                await interaction.editReply({ embeds, components });
            }

            // X·ª≠ l√Ω n√∫t ph√¢n trang
            else if (interaction.customId.startsWith('spirit_rings_')) {
                const parts = interaction.customId.split('_');
                const action = parts[2];
                const userId = parts[parts.length - 1];

                let page = 1;

                if (action === 'next' || action === 'prev' || action === 'last') {
                    page = parseInt(parts[3]);
                }

                await interaction.deferUpdate();

                const { embeds, components } = await SpiritRingController.getSpiritRingsEmbed(userId, page);
                await interaction.editReply({ embeds, components });
            }
        } catch (error) {
            console.error('L·ªói khi x·ª≠ l√Ω interaction:', error);

            // Ch·ªâ g·ª≠i th√¥ng b√°o l·ªói n·∫øu ch∆∞a tr·∫£ l·ªùi
            if (!interaction.replied && !interaction.deferred) {
                await interaction.reply({
                    content: 'ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω y√™u c·∫ßu.',
                    ephemeral: true
                });
            }
        }
    });
    client.on(Events.GuildCreate, async (guild) => {
        try {
            const developer = await client.users.fetch(process.env.DEVELOPER_ID);

            if (developer) {
                await developer.send(
                    `‚úÖ Bot v·ª´a ƒë∆∞·ª£c add v√†o server m·ªõi!\n\n**T√™n server:** ${guild.name}\nüë• **Th√†nh vi√™n:** ${guild.memberCount}\nüÜî **Server ID:** ${guild.id}`
                );
            }
        } catch (error) {
            console.error("Kh√¥ng th·ªÉ g·ª≠i DM cho developer:", error);
        }
    });
    process.on('unhandledRejection', (reason, promise) => {
        console.error('‚ö†Ô∏è Unhandled Rejection:', reason);

    });

    process.on('uncaughtException', (err) => {
        console.error('üí• Uncaught Exception:', err);
    });

    client.login(process.env.DISCORD_TOKEN);
}
catch (e) {
    console.log(e)
}